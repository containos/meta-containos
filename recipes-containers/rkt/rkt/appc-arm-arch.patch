diff --git a/common/common.go b/common/common.go
index 2f05ba6..0166f03 100644
--- a/common/common.go
+++ b/common/common.go
@@ -19,10 +19,13 @@ package common
 import (
 	"bufio"
 	"fmt"
+	"io/ioutil"
 	"net"
 	"os"
 	"os/exec"
 	"path/filepath"
+	"runtime"
+	"sort"
 	"strconv"
 	"strings"

@@ -314,3 +317,83 @@ func SystemdVersion(systemdBinaryPath string) (int, error) {

 	return version, nil
 }
+
+// Borrowed from <go>/src/cmd/dist/util.go
+func xgetgoarm() string {
+	goos := runtime.GOOS
+
+	if goos == "nacl" {
+		// NaCl guarantees VFPv3 and is always cross-compiled.
+		return "7"
+	}
+	if goos == "darwin" {
+		// Assume all darwin/arm devices are have VFPv3. This
+		// port is also mostly cross-compiled, so it makes little
+		// sense to auto-detect the setting.
+		return "7"
+	}
+	if goos == "freebsd" || goos == "openbsd" {
+		// FreeBSD has broken VFP support.
+		// OpenBSD currently only supports softfloat.
+		return "5"
+	}
+	if goos != "linux" {
+		// All other arm platforms that we support
+		// require ARMv7.
+		return "7"
+	}
+	goarm := "5"
+	cpuinfo, err := ioutil.ReadFile("/proc/cpuinfo")
+	if err != nil {
+		return goarm
+	}
+	for _, line := range strings.Split(string(cpuinfo), "\n") {
+		line := strings.SplitN(line, ":", 2)
+		if len(line) < 2 {
+			continue
+		}
+		if strings.TrimSpace(line[0]) != "Features" {
+			continue
+		}
+		features := strings.Fields(line[1])
+		sort.Strings(features) // so vfpv3 sorts after vfp
+
+		// Infer GOARM value from the vfp features available
+		// on this host. Values of GOARM detected are:
+		// 5: no vfp support was found
+		// 6: vfp (v1) support was detected, but no higher
+		// 7: vfpv3 support was detected.
+		// This matches the assertions in runtime.checkarm.
+		for _, f := range features {
+			switch f {
+			case "vfp":
+				goarm = "6"
+			case "vfpv3":
+				goarm = "7"
+			}
+		}
+	}
+	return goarm
+}
+
+// Returns current appc OS and a list of compatible architectures
+// matching local host, sorted by preference
+func LocalOSArch() (string, []string) {
+	appc_os := runtime.GOOS
+	appc_arch := []string{runtime.GOARCH}
+
+	if appc_os == "linux" && appc_arch[0] == "arm" {
+		switch xgetgoarm() {
+		case "5":
+			// Not a valid appc architecture.  This might
+			// lead to a meaningful error message.
+			appc_arch = []string{"armv5l"}
+		case "6":
+			appc_arch = []string{"armv6l"}
+		case "7":
+			appc_arch = []string{"armv7l", "armv6l"}
+		}
+	}
+
+	return appc_os, appc_arch
+}
diff --git a/rkt/fetch.go b/rkt/fetch.go
index ad50f9f..ac913f0 100644
--- a/rkt/fetch.go
+++ b/rkt/fetch.go
@@ -15,8 +15,6 @@
 package main

 import (
-	"runtime"
-
 	"github.com/appc/spec/schema/types"
 	"github.com/coreos/rkt/common/apps"
 	"github.com/coreos/rkt/rkt/image"
@@ -25,11 +23,6 @@ import (
 	"github.com/spf13/cobra"
 )

-const (
-	defaultOS   = runtime.GOOS
-	defaultArch = runtime.GOARCH
-)
-
 var (
 	cmdFetch = &cobra.Command{
 		Use:   "fetch IMAGE_URL...",
diff --git a/rkt/image/fetcher.go b/rkt/image/fetcher.go
index 28054d6..b45a126 100644
--- a/rkt/image/fetcher.go
+++ b/rkt/image/fetcher.go
@@ -20,7 +20,6 @@ import (
 	"fmt"
 	"net/url"
 	"os"
-	"runtime"
 
 	"github.com/coreos/rkt/common"
 	"github.com/coreos/rkt/common/apps"
@@ -278,15 +277,17 @@ type appBundle struct {
 }
 
 func newAppBundle(name string) (*appBundle, error) {
+	appc_os, appc_archs := common.LocalOSArch()
+
 	app, err := discovery.NewAppFromString(name)
 	if err != nil {
 		return nil, errwrap.Wrap(fmt.Errorf("invalid image name %q", name), err)
 	}
 	if _, ok := app.Labels["arch"]; !ok {
-		app.Labels["arch"] = runtime.GOARCH
+		app.Labels["arch"] = appc_archs[0]
 	}
 	if _, ok := app.Labels["os"]; !ok {
-		app.Labels["os"] = runtime.GOOS
+		app.Labels["os"] = appc_os
 	}
 	if err := types.IsValidOSArch(app.Labels, stage0.ValidOSArch); err != nil {
 		return nil, errwrap.Wrap(fmt.Errorf("invalid image name %q", name), err)
diff --git a/rkt/version.go b/rkt/version.go
index ab2232a..762a12c 100644
--- a/rkt/version.go
+++ b/rkt/version.go
@@ -16,8 +16,10 @@ package main

 import (
 	"runtime"
+	"strings"

 	"github.com/appc/spec/schema"
+	"github.com/coreos/rkt/common"
 	"github.com/coreos/rkt/version"
 	"github.com/spf13/cobra"
 )
@@ -37,8 +39,11 @@ func init() {
 }

 func runVersion(cmd *cobra.Command, args []string) (exit int) {
+	appc_os, appc_archs := common.LocalOSArch()
+
 	stdout.Printf("rkt Version: %s", version.Version)
 	stdout.Printf("appc Version: %s", schema.AppContainerVersion)
+	stdout.Printf("appc OS/Arch(s): %s/%s", appc_os, strings.Join(appc_archs, ","))
 	stdout.Printf("Go Version: %s", runtime.Version())
 	stdout.Printf("Go OS/Arch: %s/%s", runtime.GOOS, runtime.GOARCH)
 	stdout.Printf("Features: %s", rktFeatures)
diff --git a/Godeps/_workspace/src/github.com/appc/docker2aci/lib/internal/internal.go b/Godeps/_workspace/src/github.com/appc/docker2aci/lib/internal/internal.go
index 3a30663..c344114 100644
--- a/Godeps/_workspace/src/github.com/appc/docker2aci/lib/internal/internal.go
+++ b/Godeps/_workspace/src/github.com/appc/docker2aci/lib/internal/internal.go
@@ -154,8 +158,17 @@ func GenerateManifest(layerData types.DockerImageData, dockerURL *types.ParsedDo

 		if layerData.Architecture != "" {
 			arch := appctypes.MustACIdentifier("arch")
-			labels = append(labels, appctypes.Label{Name: *arch, Value: layerData.Architecture})
-			parentLabels = append(parentLabels, appctypes.Label{Name: *arch, Value: layerData.Architecture})
+			// platform.variant cleans this up a little in
+			// https://github.com/docker/distribution/blob/master/docs/spec/manifest-v2-2.md
+			// - until then just rudely assume linux/arm => armv7l
+			appcArch := layerData.Architecture
+			log.Debug("input: ", layerData.OS, "/", appcArch)
+			if layerData.OS == "linux" && appcArch == "arm" {
+				appcArch = "armv7l"
+			}
+			log.Info("output: ", layerData.OS, "/", appcArch)
+			labels = append(labels, appctypes.Label{Name: *arch, Value: appcArch})
+			parentLabels = append(parentLabels, appctypes.Label{Name: *arch, Value: appcArch})
 		}
 	}

